# 第八章 数组
## 一、定义数组
   - <类型>变量名称[元素数量];
     - `int grade[100];`
     - `double weight[20];`     
   - 元素数量必须是整数  
   - C99之前：元素数量必须是编译时时刻确定的字面量<font color=blue>(不能是变量)</font>
     - 其中所有元素具有相同的数据类型
     - 一旦创建，不能改变大小
     - 数组中的元素在内存中是连续依次排列的 
   - <font color=red>不要越界！！！</font>
### 习题   
- 编写一个程序，输入0到9之间的数字，统计每个数字出现过的次数

    ```c
    #include<stdio.h>
    int main()
    {
        const int number = 10;//我们将在程序中出现多次的数叫做Magic Number，为了区分这些相同的数，我们可以将它们依次设为常量。
        int x;
        int count[10];        //定义数组
        int i;

        for(i = 0; i < number; i++)
        {
            count[i] = 0;
        }                     //初始化数组

        scanf("%d", &x);
        while(x != -1)
        {
            if(x >= 0 && x <= 9)
            {
                count[x]++;   //数组参与运算
            }
            scanf("%d", &x);
        }

        for(i = 0; i < number; i++)
        {
            printf("%d: %d\n", i, count[i]);
        }                     //遍历数组输出
        return 0;
    }
    ```
## 二、数组运算
1. **数组的集成初始化**
   `int a[] = {2, 4, 6, 8} //数组会自动数出元素个数`
2. **集成初始化时的定位**
   `int a[10] = {[0] = 2, [2] = 3, 6}`
   - 用[n]在初始化数据中给出定位
   - 没有定位的数据接在前面的位置后面
   - 其他位置的值补零
   - 可以不给出数组大小
3. **数组的大小**
   元素数量 = `sizeof(a) / sizeof(a[0])`
4. **数组的赋值**
   - 数组变量本身不能被赋值
   - 赋值必须遍历
### 习题
- 判断素数
    ```c
    int isPrime(int x)
    {
        int ret = 1;
        int i;
        if(x == 1 || x % 2 == 0 && x != 2)
        {
            ret = 0;
        }
        for(i = 0; i < sqrt(x); i++)
        {
            ret = 0;
            break;
        }
        return ret;
    }
    ```
- 判断是否能被已知的且小于x的素数整除
  ```c
  int main()
  {
    const int number = 100;
    int prime[number] = {2}
    int count = 1;
    int i = 3;
    while(count < number)
    {
        if(isPrime(i, prime, count))
        {
            prime[count++] =  i;
        }
        i++;
    }
    //在这里添加代码
    for(i = 0; i < number; i++)
    {
        printf("%d", prime[i]);
        if((i + 1) % 5) printf("\t");
        else printf("\n");
    }
    return 0;
  }
  ```
- 构造素数表
  1. 令x为2
  2. 将2x、3x、4x直至ax < n的数标记为非素数 
  3. 令x为下一个没有被标记为非素数的数，重复2；直至所有的数都被尝试完毕
  ```c
  int main()
  {
    const int maxNumber = 25;
    int isPrime[maxNumber];
    int i;
    int x;
    for(i = 0; i < maxNumber; x++)
    {
        isPrime[i] = 1;
    }   
    for(x = 2; x < maxNumber; i++)
    {
        if(isPrime[x])
        {
            for(i = 2; i * x < maxNumber; i++)
            {
                isPrime[i * x] = 0;
            }
        }
    }
    for(i = 2; i < maxNumber; i++)
    {
        if(isPrime[i]) printf("%d\t", i);
    }
    printf("\n");
  }
  ```
## 三、二维数组
1. **二维数组的遍历**
   ```c
   for(int i = 0; i < n; i++)
   {
       for(int j = 0; j < m; j++)
       {
           a[i][j] = i * j;
       }  
   }
   ```
   - 列数不可以省略
   - 每一个{}之间都要用逗号分隔
   - 省略表示补零
`int a[][5] = { {0,1,2,3,4,5}, {5,4,3,2,1,0} }`
   - 也可以不带二级的大括号
2. **例题** 
   - 判断井字棋游戏中获胜的一方
  ```c
  int main()
  {
    const int size = 3;
    int board[size][size];
    int i, j;
    int num0fX, num0fO;
    int result = -1;    //  -1：没人赢，1：X赢，0：O赢 

    //  读入矩阵
    for(i = 0; i < size; i++)
    {
        for(j = 0; j < size; j++)
        {
            scanf("%d", board[i][j]);
        }
    }

    //  检查行
    for(i = 0; i < size && result = -1; i++)
    {
        num0fX = 0, num0fO = 0;
        for(j = 0; j < size; j++)
        {
            if(board[i][j] == 1) num0fX++;
            else num0fO++;
        }
        if(num0fX == size) result = 1;
        else if(num0fO == size) result = 0;
    }

    //  检查列/对角线：同上，此处省略
  }
  ```